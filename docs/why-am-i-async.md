In trying to scout the Rust ecosystem for a fitting web-framework for me to build my very simple blog app for, one concept keeps haunting me; `async`.

`async` is a "programming model" wherein functions/methods don't immediately return their response, but rather a "`Promise`" (or, in Rust's case: a `Future`) that can either be pending, failed, or successful. The idea being that, the rest of the program won't have to wait (or "`block`" as it's referred to in programming) for the function call to return a value, but rather continue on until the return value is actually needed. This supposedly helps immensely for certain workloads, some of which would traditionally be threaded instead, all the while sidestepping much of the overhead that's apparently traditionally incurred by threading. **Neat right?**

Well, as always, there are tradeoffs. Probably the most immediately apparent of which being how, unlike threading, **`async` code must be written as `async` from the beginning;** It's nowhere near as easy to turn a pre-existing "syncronous" application into an `async` one, compared to simply spawn syncronous functions on threads to allow for multithreading, even if "less efficient" in the long run.

However, be that as it may, as a beginner, whose still trying to grapple with the "Basics" of Rust, the `async` programming model appears somewhat unneccecary for a project such as this and, to be frank; quite daunting. I'd actually looked into `async` programming before, as it pertained to Vanilla Javascript, a language I actually feel somewhat comfortable in, yet never quite seemed to get a grip on it, no matter how many tutorials or conference-speaks I'd watched.

Well... apparently, web-services happen to scale particularly well with async, which is why most high-profile, high-performance web-frameworks for Rust, such as [Actix](https://actix.rs/), Tokio-rs's [Axum](https://github.com/tokio-rs/axum) or [Tide](https://github.com/http-rs/tide), are in fact built to be used asyncronously. As such, I feel somewhat "forced" to go `async` if I want to learn to do something like this "the right way".

There are of course still exceptions; [gotham](https://gotham.rs/) appears to be syncronous, and the rust-book itself [finishes off by instructing the reader on how to build a rudementary multi-threaded web-server](https://doc.rust-lang.org/book/ch20-00-final-project-a-web-server.html). First by developing it to be single-theaded, demonstrating it's weaknesses, and finally addessing those by implementing and utilizng a thread-pool from scratch.

This is, traditionally, the kind of incremental improvements I like to aim for; build a thing, find it's weaknesses, and address them as they come. Aim to build a codebase that's friendly to incremental improvement, as opposed to fostering delusions of "doing it all right on the first try", which more often then not tend to fail people even worse. I think this is also precisely why I struggle so with `async`, as it means having to re-learn much of my traditionally syncronous way of thinking, to solve an issue I haven't yet any actual experience with.

Even if I were to write the whole app in async, what's to say I wouldn't be falling victim to other performance pitfalls I'm not aware of cause of leaping to `async` immediately, instead of understanding what it's trying to solve?

If, for instance, rendering a post-index  syncronously proved to be exceptionally slow, say, 3+ seconds, and these requests started blocking up the thread-pool, I don't think refactoring it as an asyncronous operation would do much to help. Rather, I'd probably instead consider implementing some sort of cache for said index view that would then be served instead. Perhaps this isn't a fair example of an `async` use-case, sure, but I hope this gets my point across.